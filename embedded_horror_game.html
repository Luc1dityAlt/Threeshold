<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>THRESHOLD: 3D LIDAR Horror</title>
<style>
html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#000; }
canvas { display:block; }
#ui { position:absolute; top:10px; left:10px; color:#0f0; font-family: monospace; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">WASD to move, Shift to sprint, R to scan with LIDAR</div>
<script>
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl');

function resize(){ canvas.width=window.innerWidth; canvas.height=window.innerHeight; gl.viewport(0,0,canvas.width,canvas.height); }
window.addEventListener('resize', resize); resize();

function degToRad(d){return d*Math.PI/180;}
function createIdentity(){return [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];}

let camera={x:0,y:1.5,z:0,yaw:0,pitch:0};
let keys={};
window.addEventListener('keydown', e=>keys[e.key.toLowerCase()]=true);
window.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);
canvas.addEventListener('click', ()=>canvas.requestPointerLock());
document.addEventListener('mousemove', e=>{
  if(document.pointerLockElement===canvas){
    camera.yaw += e.movementX * 0.002;
    camera.pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.pitch + e.movementY * 0.002));
  }
});

// World walls as rays
const mapSize = 20;
const map = Array.from({length:mapSize},()=>Array(mapSize).fill(1));
for(let y=1;y<mapSize-1;y++){
  for(let x=1;x<mapSize-1;x++){
    if(Math.random()<0.3) map[y][x]=0;
  }
}
map[Math.floor(mapSize/2)][Math.floor(mapSize/2)] = 0; // starting point

let lidarDots=[];
let canScan=true;

function createShader(gl,type,src){let s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)){console.error(gl.getShaderInfoLog(s));} return s;}
function createProgram(gl,vsrc,fsrc){let vs=createShader(gl,gl.VERTEX_SHADER,vsrc); let fs=createShader(gl,gl.FRAGMENT_SHADER,fsrc); let p=gl.createProgram(); gl.attachShader(p,vs); gl.attachShader(p,fs); gl.linkProgram(p); if(!gl.getProgramParameter(p,gl.LINK_STATUS)){console.error(gl.getProgramInfoLog(p));} return p;}

const vShaderSrc=`attribute vec3 a_position; uniform mat4 u_proj; uniform mat4 u_view; void main(){gl_Position=u_proj*u_view*vec4(a_position,1.0); gl_PointSize=3.0;}`;
const fShaderSrc=`void main(){gl_FragColor=vec4(0.0,1.0,0.0,1.0);}`;
const program=createProgram(gl,vShaderSrc,fShaderSrc);
const posLoc=gl.getAttribLocation(program,'a_position');
const uProj=gl.getUniformLocation(program,'u_proj');
const uView=gl.getUniformLocation(program,'u_view');
const pointBuffer=gl.createBuffer();

function perspective(fov,aspect,near,far){ let f=1/Math.tan(fov/2); let nf=1/(near-far); return [f/aspect,0,0,0,0,f,0,0,0,0,(far+near)*nf,-1,0,0,(2*far*near)*nf,0]; }

function castRay(origin,angle,maxDist){
  let sin=Math.sin(angle), cos=Math.cos(angle);
  for(let d=0;d<maxDist;d+=0.1){
    let x=origin.x+cos*d, z=origin.z+sin*d;
    let tx=Math.floor(x+mapSize/2), tz=Math.floor(z+mapSize/2);
    if(map[tz] && map[tz][tx]===1) return {x:x,y:origin.y,z:z};
  }
  return null;
}

function update(dt){
  let speed=0.05*(keys['shift']?2:1);
  let dirX=Math.sin(camera.yaw); let dirZ=Math.cos(camera.yaw);
  let rightX=Math.sin(camera.yaw+Math.PI/2); let rightZ=Math.cos(camera.yaw+Math.PI/2);

  if(keys['w']){camera.x+=dirX*speed; camera.z+=dirZ*speed;}
  if(keys['s']){camera.x-=dirX*speed; camera.z-=dirZ*speed;}
  if(keys['a']){camera.x-=rightX*speed; camera.z-=rightZ*speed;}
  if(keys['d']){camera.x+=rightX*speed; camera.z+=rightZ*speed;}

  if(keys['r'] && canScan){
    canScan=false;
    let rays=100; let maxDist=20;
    for(let i=0;i<rays;i++){
      let a=camera.yaw - Math.PI/4 + (i/rays)*(Math.PI/2);
      let hit=castRay(camera,a,maxDist);
      if(hit) lidarDots.push(hit);
    }
    setTimeout(()=>{canScan=true;},2000);
  }
}

function render(){
  gl.clearColor(0,0,0,1); gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
  const proj=perspective(degToRad(60),canvas.width/canvas.height,0.1,100);
  const view=createIdentity(); view[12]=-camera.x; view[13]=-camera.y; view[14]=-camera.z;
  gl.useProgram(program);
  gl.uniformMatrix4fv(uProj,false,new Float32Array(proj));
  gl.uniformMatrix4fv(uView,false,new Float32Array(view));
  
  let positions=[];
  // casted walls as points
  for(let i=0;i<100;i++){
    let angle=-Math.PI/4 + i*(Math.PI/50);
    let hit=castRay(camera,angle,20);
    if(hit) positions.push(hit.x,hit.y,hit.z);
  }
  for(let d of lidarDots){ positions.push(d.x,d.y,d.z); }
  gl.bindBuffer(gl.ARRAY_BUFFER,pointBuffer);
  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(positions),gl.STATIC_DRAW);
  gl.enableVertexAttribArray(posLoc); gl.vertexAttribPointer(posLoc,3,gl.FLOAT,false,0,0);
  gl.drawArrays(gl.POINTS,0,positions.length/3);
}

let last=performance.now();
function loop(now){ const dt=(now-last)/16; last=now; update(dt); render(); requestAnimationFrame(loop); }
requestAnimationFrame(loop);
</script>
</body>
</html>
