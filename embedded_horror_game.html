<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>THRESHOLD: 3D LIDAR Horror</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: #000;
}
canvas { display:block; }
#ui { position:absolute; top:10px; left:10px; color:#0f0; font-family: monospace; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">WASD to move, Shift to sprint, R to scan with LIDAR</div>
<script>
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl');

function resize(){ canvas.width=window.innerWidth; canvas.height=window.innerHeight; gl.viewport(0,0,canvas.width,canvas.height); }
window.addEventListener('resize',resize); resize();

// 3D Math helpers
function degToRad(d){return d*Math.PI/180;}
function createIdentity(){return [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];}
function multiplyMat4(a,b){ let out = []; for(let i=0;i<4;i++){for(let j=0;j<4;j++){out[i*4+j]=a[i*4]*b[j]+a[i*4+1]*b[j+4]+a[i*4+2]*b[j+8]+a[i*4+3]*b[j+12];}} return out; }

// Camera
let camera = {x:0,y:1.5,z:0,angle:0};
let keys = {};
window.addEventListener('keydown', e=>keys[e.key.toLowerCase()]=true);
window.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);
canvas.addEventListener('click', ()=>canvas.requestPointerLock());
document.addEventListener('mousemove', e=>{if(document.pointerLockElement===canvas){camera.angle+=e.movementX*0.002;}});

// World grid
const walls = [];
for(let x=-10;x<=10;x+=2){for(let z=-10;z<=10;z+=2){walls.push({x,y:0,z});}}

// LIDAR
let lidarDots=[];
let scanning=false;

// 3D rendering setup
function createShader(gl,type,src){let s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)){console.error(gl.getShaderInfoLog(s));} return s;}
function createProgram(gl,vsrc,fsrc){let vs=createShader(gl,gl.VERTEX_SHADER,vsrc); let fs=createShader(gl,gl.FRAGMENT_SHADER,fsrc); let p=gl.createProgram(); gl.attachShader(p,vs); gl.attachShader(p,fs); gl.linkProgram(p); if(!gl.getProgramParameter(p,gl.LINK_STATUS)){console.error(gl.getProgramInfoLog(p));} return p;}

// Vertex shader for points
const vShaderSrc=`attribute vec3 a_position; uniform mat4 u_proj; uniform mat4 u_view; void main(){gl_Position=u_proj*u_view*vec4(a_position,1.0); gl_PointSize=4.0;}`;
const fShaderSrc=`void main(){gl_FragColor=vec4(0.0,1.0,0.0,1.0);}`;
const program = createProgram(gl,vShaderSrc,fShaderSrc);
const posLoc = gl.getAttribLocation(program,'a_position');
const uProj = gl.getUniformLocation(program,'u_proj');
const uView = gl.getUniformLocation(program,'u_view');

const pointBuffer = gl.createBuffer();

function perspective(fov,aspect,near,far){
  let f=1/Math.tan(fov/2); let nf=1/(near-far);
  return [f/aspect,0,0,0,0,f,0,0,0,0,(far+near)*nf,-1,0,0,(2*far*near)*nf,0];
}

function update(dt){
  let speed = 0.05*(keys['shift']?2:1);
  if(keys['w']){camera.x+=Math.sin(camera.angle)*speed; camera.z+=Math.cos(camera.angle)*speed;}
  if(keys['s']){camera.x-=Math.sin(camera.angle)*speed; camera.z-=Math.cos(camera.angle)*speed;}
  if(keys['a']){camera.x-=Math.cos(camera.angle)*speed; camera.z+=Math.sin(camera.angle)*speed;}
  if(keys['d']){camera.x+=Math.cos(camera.angle)*speed; camera.z-=Math.sin(camera.angle)*speed;}

  if(keys['r'] && !scanning){ scanning=true; lidarDots=[]; for(let w of walls){ lidarDots.push({x:w.x,y:w.y,z:w.z});} setTimeout(()=>{scanning=false;},2000); }
}

function render(){
  gl.clearColor(0,0,0,1); gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

  // Project and view matrices
  const proj = perspective(degToRad(60),canvas.width/canvas.height,0.1,100);
  const cx=Math.sin(camera.angle), cz=Math.cos(camera.angle);
  const view=createIdentity(); view[12]=-camera.x; view[13]=-camera.y; view[14]=-camera.z;

  gl.useProgram(program);
  gl.uniformMatrix4fv(uProj,false,new Float32Array(proj));
  gl.uniformMatrix4fv(uView,false,new Float32Array(view));

  // LIDAR points
  let positions=[];
  for(let dot of lidarDots){ positions.push(dot.x,dot.y,dot.z);}
  gl.bindBuffer(gl.ARRAY_BUFFER,pointBuffer);
  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(positions),gl.STATIC_DRAW);
  gl.enableVertexAttribArray(posLoc); gl.vertexAttribPointer(posLoc,3,gl.FLOAT,false,0,0);
  gl.drawArrays(gl.POINTS,0,positions.length/3);
}

let last=performance.now();
function loop(now){ let dt=(now-last)/16; last=now; update(dt); render(); requestAnimationFrame(loop); }
requestAnimationFrame(loop);
</script>
</body>
</html>
