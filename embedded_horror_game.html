<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>THRESHOLD: 3D LIDAR Horror</title>
<style>
html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#000; }
canvas { display:block; }
#ui { position:absolute; top:10px; left:10px; color:#0f0; font-family: monospace; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">WASD to move, Shift to sprint, R to scan with LIDAR</div>
<script>
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl');

function resize(){ canvas.width=window.innerWidth; canvas.height=window.innerHeight; gl.viewport(0,0,canvas.width,canvas.height); }
window.addEventListener('resize', resize); resize();

function degToRad(d){return d*Math.PI/180;}
function createIdentity(){return [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];}

let camera={x:0,y:1.5,z:0,yaw:0,pitch:0};
let keys={};
window.addEventListener('keydown', e=>keys[e.key.toLowerCase()]=true);
window.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);
canvas.addEventListener('click', ()=>canvas.requestPointerLock());
document.addEventListener('mousemove', e=>{
  if(document.pointerLockElement===canvas){
    camera.yaw += e.movementX * 0.002;
    camera.pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.pitch + e.movementY * 0.002));
  }
});

// World walls
const walls=[];
for(let x=-10;x<=10;x+=2){for(let z=-10;z<=10;z+=2){walls.push({x,y:0,z});}}
let lidarDots=[];
let canScan=true;

function createShader(gl,type,src){let s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)){console.error(gl.getShaderInfoLog(s));} return s;}
function createProgram(gl,vsrc,fsrc){let vs=createShader(gl,gl.VERTEX_SHADER,vsrc); let fs=createShader(gl,gl.FRAGMENT_SHADER,fsrc); let p=gl.createProgram(); gl.attachShader(p,vs); gl.attachShader(p,fs); gl.linkProgram(p); if(!gl.getProgramParameter(p,gl.LINK_STATUS)){console.error(gl.getProgramInfoLog(p));} return p;}

const vShaderSrc=`attribute vec3 a_position; uniform mat4 u_proj; uniform mat4 u_view; void main(){gl_Position=u_proj*u_view*vec4(a_position,1.0); gl_PointSize=4.0;}`;
const fShaderSrc=`void main(){gl_FragColor=vec4(0.0,1.0,0.0,1.0);}`;
const program=createProgram(gl,vShaderSrc,fShaderSrc);
const posLoc=gl.getAttribLocation(program,'a_position');
const uProj=gl.getUniformLocation(program,'u_proj');
const uView=gl.getUniformLocation(program,'u_view');
const pointBuffer=gl.createBuffer();

function perspective(fov,aspect,near,far){ let f=1/Math.tan(fov/2); let nf=1/(near-far); return [f/aspect,0,0,0,0,f,0,0,0,0,(far+near)*nf,-1,0,0,(2*far*near)*nf,0]; }

function update(dt){
  let speed=0.05*(keys['shift']?2:1);
  let dirX=Math.sin(camera.yaw)*Math.cos(camera.pitch);
  let dirZ=Math.cos(camera.yaw)*Math.cos(camera.pitch);
  let rightX=Math.sin(camera.yaw+Math.PI/2);
  let rightZ=Math.cos(camera.yaw+Math.PI/2);

  if(keys['w']){camera.x+=dirX*speed; camera.z+=dirZ*speed;}
  if(keys['s']){camera.x-=dirX*speed; camera.z-=dirZ*speed;}
  if(keys['a']){camera.x-=rightX*speed; camera.z-=rightZ*speed;}
  if(keys['d']){camera.x+=rightX*speed; camera.z+=rightZ*speed;}

  if(keys['r'] && canScan){
    canScan=false;
    lidarDots=[];
    for(let i=0;i<360;i+=5){
      let angle = camera.yaw + i*Math.PI/180;
      for(let r=0;r<20;r+=0.5){
        lidarDots.push({x:camera.x+Math.sin(angle)*r, y:camera.y, z:camera.z+Math.cos(angle)*r});
      }
    }
    setTimeout(()=>{canScan=true;},2000);
  }
}

function render(){
  gl.clearColor(0,0,0,1); gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
  const proj=perspective(degToRad(60),canvas.width/canvas.height,0.1,100);
  const view=createIdentity(); view[12]=-camera.x; view[13]=-camera.y; view[14]=-camera.z;
  gl.useProgram(program);
  gl.uniformMatrix4fv(uProj,false,new Float32Array(proj));
  gl.uniformMatrix4fv(uView,false,new Float32Array(view));
  
  // Draw walls as LIDAR dots for testing
  let positions=[];
  for(let w of walls){ positions.push(w.x,w.y,w.z); }
  for(let d of lidarDots){ positions.push(d.x,d.y,d.z); }
  gl.bindBuffer(gl.ARRAY_BUFFER,pointBuffer);
  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(positions),gl.STATIC_DRAW);
  gl.enableVertexAttribArray(posLoc); gl.vertexAttribPointer(posLoc,3,gl.FLOAT,false,0,0);
  gl.drawArrays(gl.POINTS,0,positions.length/3);
}

let last=performance.now();
function loop(now){ const dt=(now-last)/16; last=now; update(dt); render(); requestAnimationFrame(loop); }
requestAnimationFrame(loop);
</script>
</body>
</html>
